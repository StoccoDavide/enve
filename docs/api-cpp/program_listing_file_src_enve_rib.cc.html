
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Program Listing for File enve_rib.cc &#8212; ENVE v1.0
</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/table_styling.css" />
    <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css" />
    <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
    <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
    <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="program-listing-for-file-enve-rib-cc">
<span id="program-listing-file-src-enve-rib-cc"></span><h1>Program Listing for File enve_rib.cc<a class="headerlink" href="#program-listing-for-file-enve-rib-cc" title="Permalink to this headline">¶</a>
</h1>
<p>↰ <a class="reference internal" href="file_src_enve_rib.cc.html#file-src-enve-rib-cc"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/enve_rib.cc</span></code>)</p>
<div class="highlight-cpp notranslate">
<div class="highlight"><pre><span></span>/*
(***********************************************************************)
(*                                                                     *)
(* The ENVE project                                                    *)
(*                                                                     *)
(* Copyright (c) 2020-2021, Davide Stocco and Enrico Bertolazzi.       *)
(*                                                                     *)
(* The ENVE project and its components are supplied under the terms of *)
(* the open source BSD 2-Clause License. The contents of the ENVE      *)
(* project and its components may not be copied or disclosed except in *)
(* accordance with the terms of the BSD 2-Clause License.              *)
(*                                                                     *)
(* URL: https://opensource.org/licenses/BSD-2-Clause                   *)
(*                                                                     *)
(*    Davide Stocco                                                    *)
(*    Department of Industrial Engineering                             *)
(*    University of Trento                                             *)
(*    e-mail: davide.stocco@unitn.it                                   *)
(*                                                                     *)
(*    Enrico Bertolazzi                                                *)
(*    Department of Industrial Engineering                             *)
(*    University of Trento                                             *)
(*    e-mail: enrico.bertolazzi@unitn.it                               *)
(*                                                                     *)
(***********************************************************************)
*/


#include "enve_rib.hh"

using namespace acme;

namespace enve
{

  /*\
   |        _ _
   |   _ __(_) |__
   |  | '__| | '_ \
   |  | |  | | |_) |
   |  |_|  |_|_.__/
   |
  \*/

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::~rib()
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib()
    : disk(NAN_DISK),
      m_width(QUIET_NAN),
      m_angle(QUIET_NAN)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib(
    real         radius,
    plane const &amp;plane,
    real         width,
    real         angle)
    : disk(radius, plane),
      m_width(width),
      m_angle(angle)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib(
    real         radius,
    plane const &amp;plane)
    : disk(radius, plane),
      m_width(QUIET_NAN),
      m_angle(QUIET_NAN)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib(
    real         radius,
    point const &amp;center,
    vec3  const &amp;normal,
    real         width,
    real         angle)
    : disk(radius, center, normal),
      m_width(width),
      m_angle(angle)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib(
    real radius,
    real center_x,
    real center_y,
    real center_z,
    real normal_x,
    real normal_y,
    real normal_z,
    real width,
    real angle)
    : disk(radius, center_x, center_y, center_z, normal_x, normal_y, normal_z),
      m_width(width),
      m_angle(angle)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib(
    real radius,
    real center_x,
    real center_y,
    real center_z,
    real normal_x,
    real normal_y,
    real normal_z)
    : disk(radius, center_x, center_y, center_z, normal_x, normal_y, normal_z),
      m_width(QUIET_NAN),
      m_angle(QUIET_NAN)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib &amp;
  rib::operator=(
    rib const &amp;rib_in
  )
  {
    if (this == &amp;rib_in)
    {
      return *this;
    }
    else
    {
      this-&gt;disk::operator=(rib_in);
      this-&gt;m_width       = rib_in.m_width;
      this-&gt;m_angle       = rib_in.m_angle;
      return *this;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  void
  rib::copy(
    rib const &amp;rib_in
  )
  {
    this-&gt;radius()      = rib_in.radius();
    this-&gt;layingPlane() = rib_in.layingPlane();
    this-&gt;m_width       = rib_in.m_width;
    this-&gt;m_angle       = rib_in.m_angle;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  real const &amp;
  rib::width(void)
    const
  {
    return this-&gt;m_width;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  real const &amp;
  rib::angle(void)
    const
  {
    return this-&gt;m_angle;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  real &amp;
  rib::width(void)
  {
    return this-&gt;m_width;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  real &amp;
  rib::angle(void)
  {
    return this-&gt;m_angle;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::isApprox(
    rib const &amp;rib_in,
    real       tolerance
  )
    const
  {
    return this-&gt;disk::isApprox(rib_in) &amp;&amp;
           acme::isApprox(this-&gt;m_width, rib_in.m_width, tolerance) &amp;&amp;
           acme::isApprox(this-&gt;m_angle, rib_in.m_angle, tolerance);
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelop(
    triangleground::vecptr const &amp;localGround,
    affine                 const &amp;affine_in,
    std::string            const  method,
    output                       &amp;out
  )
    const
  {
    if (method == "geometric")
      return this-&gt;envelopGeometric(localGround, affine_in, out);
    else if (method == "sampling")
      return this-&gt;envelopSampling(localGround, affine_in, out);
    else
      ENVE_ERROR("enve::rib::envelop(mesh, ...): invalid enveloping method.\n");
  }

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelop(
    ground::flat const &amp;localGround,
    affine       const &amp;affine_in,
    std::string  const  method,
    output             &amp;out
  )
    const
  {
    if (method == "geometric")
      return this-&gt;envelopGeometric(localGround, affine_in, out);
    else if (method == "sampling")
      return this-&gt;envelopSampling(localGround, affine_in, out);
    else
      ENVE_ERROR("enve::rib::envelop(mesh, ...): invalid enveloping method.\n");
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelop(
    affine const &amp;affine_in,
    output       &amp;out
  )
    const
  {
    point origin(affine_in.translation());
    mat3  rotation(affine_in.linear());

    out.point    = origin + rotation * (this-&gt;center() - point(0.0, 0.0, this-&gt;radius()));
    out.normal   = rotation * UNITZ_VEC3;
    out.friction = 0.0;
    out.depth    = 0.0;
    out.area     = 0.0;
    out.volume   = 0.0;

    return false;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelopGeometric(
    triangleground::vecptr const &amp;localGround,
    affine                 const &amp;affine_in,
    output                       &amp;out
  )
    const
  {
    real  radius = this-&gt;radius();
    real  width  = this-&gt;width();
    point center = this-&gt;center();
    point origin(affine_in.translation());
    mat3  rotation(affine_in.linear());

    bool int_bool = false;

    segment segment_tmp;
    real    FA, FC, FB;
    real    segmentLength_tmp;
    real    segmentArea_tmp;
    real    segmentVolume_tmp;
    real    segmentAreaTotal   = 0.0;
    real    segmentVolumeTotal = 0.0;

    point contactPoint_tmp    = point::Constant(0.0);
    vec3  contactNormal_tmp   = vec3::Constant(0.0);
    real  contactFriction_tmp = 0.0;

    point contactPoint_iter    = point::Constant(0.0);
    vec3  contactNormal_iter   = vec3::Constant(0.0);
    real  contactFriction_iter = 0.0;

    vec3  ribNormalGround(rotation * this-&gt;normal());
    point ribCenterGround(origin + rotation * center);
    disk  ribGround(radius, ribCenterGround, ribNormalGround);

    for (size_t i = 0; i &lt; localGround.size(); ++i)
    {
      if (acme::intersection(*localGround[i], ribGround, segment_tmp, EPSILON_LOW))
      {
        segmentLength_tmp = segment_tmp.length();
        if (segmentLength_tmp &lt; EPSILON_HIGH)
          break;

        // Simpson's rule
        FA = std::max(0.0, radius - (segment_tmp.vertex(0) - ribCenterGround).norm());
        FC = std::max(0.0, radius - (segment_tmp.centroid() - ribCenterGround).norm());
        FB = std::max(0.0, radius - (segment_tmp.vertex(1) - ribCenterGround).norm());

        int_bool = true;

        segmentArea_tmp   = segmentLength_tmp * width;
        segmentAreaTotal += segmentArea_tmp;

        segmentVolume_tmp   = segmentLength_tmp/6 * (FA + 4*FC + FB) * width;
        segmentVolumeTotal += segmentVolume_tmp;

        contactPoint_iter    = (segment_tmp.vertex(0)*FA + segment_tmp.centroid()*4*FC + segment_tmp.vertex(1)*FB) / (FA + 4*FC + FB);
        contactNormal_iter   = ((ribCenterGround - contactPoint_iter).normalized() +
                                ribNormalGround*ribNormalGround.dot(localGround[i]-&gt;normal())
                                ).normalized();
        contactFriction_iter = localGround[i]-&gt;friction();

        contactPoint_tmp    += segmentVolume_tmp * contactPoint_iter;
        contactNormal_tmp   += segmentVolume_tmp * contactNormal_iter;
        contactFriction_tmp += segmentVolume_tmp * contactFriction_iter;

      }
    }
    if (int_bool)
    {
      if (segmentAreaTotal &lt; EPSILON_HIGH)
        segmentAreaTotal   += EPSILON_HIGH;

      if (segmentVolumeTotal &lt; EPSILON_HIGH)
        segmentVolumeTotal += EPSILON_HIGH;

      out.point    = contactPoint_tmp    / segmentVolumeTotal;
      out.normal   = (contactNormal_tmp  / segmentVolumeTotal).normalized();
      out.friction = contactFriction_tmp / segmentVolumeTotal;
      out.depth    = radius - (out.point - ribCenterGround).norm();
      out.area     = segmentAreaTotal;
      out.volume   = segmentVolumeTotal;
      return true;
    }
    else
    {
      out.point    = origin + rotation * (center - point(0.0, 0.0, radius));
      out.normal   = rotation * UNITZ_VEC3;
      out.friction = 0.0;
      out.depth    = 0.0;
      out.area     = 0.0;
      out.volume   = 0.0;
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelopGeometric(
    ground::flat const &amp;localGround,
    affine       const &amp;affine_in,
    output             &amp;out
  )
    const
  {
    real  radius = this-&gt;radius();
    real  width  = this-&gt;width();
    point center(this-&gt;center());
    point origin(affine_in.translation());
    mat3  rotation(affine_in.linear());

    vec3  ribNormalGround(rotation * this-&gt;normal());
    point ribCenterGround(origin + rotation * center);
    disk ribGround(radius, ribCenterGround, ribNormalGround);
    segment segment_tmp;
    if (acme::intersection(localGround, ribGround, segment_tmp, EPSILON_LOW))
    {
      out.point    = segment_tmp.centroid();
      out.normal   = ((ribCenterGround - out.point).normalized() +
                        ribNormalGround*ribNormalGround.dot(localGround.normal())
                        ).normalized();
      out.friction = localGround.friction();
      out.depth    = radius - (out.point - ribCenterGround).norm();
      out.area     = 2*std::sqrt(out.depth*(2*radius-out.depth))*width;
      out.volume   = (radius*radius*std::acos((radius-out.depth)/radius) -
                        (radius-out.depth)*std::sqrt(out.depth*(2*radius-out.depth)))*width;
      return true;
    }
    else
    {
      out.point    = origin + rotation * (center - point(0.0, 0.0, radius));
      out.normal   = rotation * UNITZ_VEC3;
      out.friction = 0.0;
      out.depth    = 0.0;
      out.area     = 0.0;
      out.volume   = 0.0;
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelopSampling(
    triangleground::vecptr const &amp;localGround,
    affine                 const &amp;affine_in,
    output                       &amp;out
  )
    const
  {
    real  radius = this-&gt;radius();
    real  width  = this-&gt;width();
    point center(this-&gt;center());
    point origin(affine_in.translation());
    mat3  rotation(affine_in.linear());

    vec3  deltaX(0.1*radius, 0.0, 0.0);
    vec3  deltaY(0.0, 0.3*width, 0.0);
    std::vector&lt;point&gt; point_vec(4);
    vec3               normal_tmp;
    std::vector&lt;real&gt;  friction_vec(4);
    vec3  ribNormalGround(rotation * this-&gt;normal());
    point ribCenterGround(origin + rotation * center);

    vec3  lineDirection(rotation * (-UNITZ_VEC3));
    int sampling = true;
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center + deltaX), lineDirection, point_vec[0], normal_tmp, friction_vec[0]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center - deltaX), lineDirection, point_vec[1], normal_tmp, friction_vec[1]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center + deltaY), lineDirection, point_vec[2], normal_tmp, friction_vec[2]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center - deltaY), lineDirection, point_vec[3], normal_tmp, friction_vec[3]);

    out.point = (point_vec[0] + point_vec[1] + point_vec[2] + point_vec[3]) / 4.0;
    if ( sampling &amp;&amp; (ribCenterGround - out.point).norm() &lt;= radius )
    {
      out.normal   = ((ribCenterGround - out.point).normalized() +
                        ribNormalGround*ribNormalGround.dot(((point_vec[0] - point_vec[1]).cross(point_vec[2] - point_vec[3])).normalized())
                        ).normalized();
      out.friction = (friction_vec[0] + friction_vec[1] + friction_vec[2] + friction_vec[3]) / 4.0;
      out.depth    = radius - (out.point - ribCenterGround).norm();
      out.area     = 2*std::sqrt(out.depth*(2*radius-out.depth))*width;
      out.volume   = (radius*radius*std::acos((radius-out.depth)/radius) -
                        (radius-out.depth)*std::sqrt(out.depth*(2*radius-out.depth)))*width;
      return true;
    }
    else
    {
      out.point    = origin + rotation * (center - point(0.0, 0.0, radius));
      out.normal   = rotation * UNITZ_VEC3;
      out.friction = 0.0;
      out.depth    = 0.0;
      out.area     = 0.0;
      out.volume   = 0.0;
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelopSampling(
    ground::flat const &amp;localGround,
    affine       const &amp;affine_in,
    output             &amp;out
  )
    const
  {
    real  radius = this-&gt;radius();
    real  width  = this-&gt;width();
    point center(this-&gt;center());
    point origin(affine_in.translation());
    mat3  rotation(affine_in.linear());

    vec3  deltaX(0.1*radius, 0.0, 0.0);
    vec3  deltaY(0.0, 0.3*width, 0.0);
    std::vector&lt;point&gt; point_vec(4);
    vec3               normal_tmp;
    std::vector&lt;real&gt;  friction_vec(4);
    vec3  ribNormalGround(rotation * this-&gt;normal());
    point ribCenterGround(origin + rotation * center);

    vec3  lineDirection(rotation * (-UNITZ_VEC3));
    bool sampling = true;
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center + deltaX), lineDirection, point_vec[0], normal_tmp, friction_vec[0]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center - deltaX), lineDirection, point_vec[1], normal_tmp, friction_vec[1]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center + deltaY), lineDirection, point_vec[2], normal_tmp, friction_vec[2]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center - deltaY), lineDirection, point_vec[3], normal_tmp, friction_vec[3]);

    out.point = (point_vec[0] + point_vec[1] + point_vec[2] + point_vec[3]) / 4.0;

    if ( sampling &amp;&amp; (ribCenterGround - out.point).norm() &lt;= radius )
    {
      out.normal   = ((ribCenterGround - out.point).normalized() +
                        ribNormalGround*ribNormalGround.dot(((point_vec[0] - point_vec[1]).cross(point_vec[2] - point_vec[3])).normalized())
                        ).normalized();
      out.friction = (friction_vec[0] + friction_vec[1] + friction_vec[2] + friction_vec[3]) / 4.0;
      out.depth    = radius - (out.point - ribCenterGround).norm();
      out.area     = 2*std::sqrt(out.depth*(2*radius-out.depth))*width;
      out.volume   = (radius*radius*std::acos((radius-out.depth)/radius) -
                        (radius-out.depth)*std::sqrt(out.depth*(2*radius-out.depth)))*width;
      return true;
    }
    else
    {
      out.point    = origin + rotation * (center - point(0.0, 0.0, radius));
      out.normal   = rotation * UNITZ_VEC3;
      out.friction = 0.0;
      out.depth    = 0.0;
      out.area     = 0.0;
      out.volume   = 0.0;
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::samplingLine(
    triangleground::vecptr const &amp;localGround,
    point const                  &amp;origin,
    vec3 const                   &amp;direction,
    point                        &amp;contactPoint,
    vec3                         &amp;contactNormal,
    real                         &amp;contactFriction
  )
    const
  {
    point              point_tmp;
    std::vector&lt;point&gt; point_vec;
    std::vector&lt;vec3&gt;  normal_vec;
    std::vector&lt;real&gt;  friction_vec;
    bool               int_bool = false;
    for (size_t i = 0; i &lt; localGround.size(); ++i)
    {
      if (acme::intersection(line(origin, direction), *localGround[i], point_tmp, EPSILON_LOW))
      {
        point_vec.push_back(point_tmp);
        normal_vec.push_back(localGround[i]-&gt;normal());
        friction_vec.push_back(localGround[i]-&gt;friction());
        int_bool = true;
      }
    }
    // Select the highest intersection point
    if (point_vec.size() == 1 &amp;&amp; int_bool)
    {
      contactPoint    = point_vec[0];
      contactNormal   = normal_vec[0];
      contactFriction = friction_vec[0];
      return true;
    }
    else if (point_vec.size() &gt; 1 &amp;&amp; int_bool)
    {
      contactPoint    = point_vec[0];
      contactNormal   = normal_vec[0];
      contactFriction = friction_vec[0];
      for (size_t j = 1; j &lt; point_vec.size(); ++j)
      {
        if (point_vec[j].z() &gt; contactPoint.z())
        {
          contactPoint    = point_vec[j];
          contactNormal   = normal_vec[j];
          contactFriction = friction_vec[j];
        }
      }
      return true;
    }
    else if (localGround.size() &gt; 0 &amp;&amp; !int_bool)
    {
      // Flying over the mesh
      return false;
    }
    else if (localGround.size() == 0)
    {
      // Out of mesh
      return false;
    }
    else
    {
      ENVE_ERROR("enve::rib::samplingLine(mesh, ...): not handled condition.");
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::samplingLine(
    ground::flat const &amp;localGround,
    point        const &amp;origin,
    vec3         const &amp;direction,
    point              &amp;contactPoint,
    vec3               &amp;contactNormal,
    real               &amp;contactFriction
  )
    const
  {
    if (acme::intersection(line(origin, direction), localGround, contactPoint, EPSILON_LOW))
    {
      contactNormal   = localGround.normal();
      contactFriction = localGround.friction();
      return true;
    }
    else
    {
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

} // namespace enve
</pre></div>
</div>
</div>



          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">The ENVE library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">How to use ENVE</a></li>
<li class="toctree-l1"><a class="reference internal" href="root.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-matlab/root.html">MATLAB API</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Davide Stocco.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>