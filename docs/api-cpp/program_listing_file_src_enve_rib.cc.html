
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Program Listing for File enve_rib.cc &#8212; ENVE v1.2
</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/table_styling.css" />
    <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css" />
    <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
    <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
    <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="program-listing-for-file-enve-rib-cc">
<span id="program-listing-file-src-enve-rib-cc"></span><h1>Program Listing for File enve_rib.cc<a class="headerlink" href="#program-listing-for-file-enve-rib-cc" title="Permalink to this headline">¶</a>
</h1>
<p>↰ <a class="reference internal" href="file_src_enve_rib.cc.html#file-src-enve-rib-cc"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/enve_rib.cc</span></code>)</p>
<div class="highlight-cpp notranslate">
<div class="highlight"><pre><span></span>/*
(***********************************************************************)
(*                                                                     *)
(* The ENVE project                                                    *)
(*                                                                     *)
(* Copyright (c) 2020, Davide Stocco and Enrico Bertolazzi.            *)
(*                                                                     *)
(* The ENVE project and its components are supplied under the terms of *)
(* the open source BSD 2-Clause License. The contents of the ENVE      *)
(* project and its components may not be copied or disclosed except in *)
(* accordance with the terms of the BSD 2-Clause License.              *)
(*                                                                     *)
(* URL: https://opensource.org/licenses/BSD-2-Clause                   *)
(*                                                                     *)
(*    Davide Stocco                                                    *)
(*    Department of Industrial Engineering                             *)
(*    University of Trento                                             *)
(*    e-mail: davide.stocco@unitn.it                                   *)
(*                                                                     *)
(*    Enrico Bertolazzi                                                *)
(*    Department of Industrial Engineering                             *)
(*    University of Trento                                             *)
(*    e-mail: enrico.bertolazzi@unitn.it                               *)
(*                                                                     *)
(***********************************************************************)
*/


#include "enve_rib.hh"

using namespace acme;

namespace enve
{

  /*\
   |        _ _
   |   _ _(_) |_
   |  | '_| | '_ \
   |  | |  | | |_) |
   |  |_|  |_|_._/
   |
  \*/

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::~rib()
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib()
    : disk(NAN_DISK),
      m_width(QUIET_NAN),
      m_angle(QUIET_NAN)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib(
    real         radius,
    plane const &amp;plane,
    real         width,
    real         angle
  )
    : disk(radius, plane),
      m_width(width),
      m_angle(angle)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib(
    real         radius,
    plane const &amp;plane
  )
    : disk(radius, plane),
      m_width(QUIET_NAN),
      m_angle(QUIET_NAN)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib(
    real         radius,
    point const &amp;center,
    vec3  const &amp;normal,
    real         width,
    real         angle
  )
    : disk(radius, center, normal),
      m_width(width),
      m_angle(angle)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib(
    real radius,
    real center_x,
    real center_y,
    real center_z,
    real normal_x,
    real normal_y,
    real normal_z,
    real width,
    real angle
  )
    : disk(radius, center_x, center_y, center_z, normal_x, normal_y, normal_z),
      m_width(width),
      m_angle(angle)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib::rib(
    real radius,
    real center_x,
    real center_y,
    real center_z,
    real normal_x,
    real normal_y,
    real normal_z
  )
    : disk(radius, center_x, center_y, center_z, normal_x, normal_y, normal_z),
      m_width(QUIET_NAN),
      m_angle(QUIET_NAN)
  {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rib &amp;
  rib::operator=(
    rib const &amp;rib_in
  )
  {
    if (this == &amp;rib_in)
    {
      return *this;
    }
    else
    {
      this-&gt;disk::operator=(rib_in);
      this-&gt;m_width       = rib_in.m_width;
      this-&gt;m_angle       = rib_in.m_angle;
      return *this;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  void
  rib::copy(
    rib const &amp;rib_in
  )
  {
    this-&gt;radius()      = rib_in.radius();
    this-&gt;layingPlane() = rib_in.layingPlane();
    this-&gt;m_width       = rib_in.m_width;
    this-&gt;m_angle       = rib_in.m_angle;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  real const &amp;
  rib::width(void)
    const
  {
    return this-&gt;m_width;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  real const &amp;
  rib::angle(void)
    const
  {
    return this-&gt;m_angle;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  real &amp;
  rib::width(void)
  {
    return this-&gt;m_width;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  real &amp;
  rib::angle(void)
  {
    return this-&gt;m_angle;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::isApprox(
    rib  const &amp;rib_in,
    real        tolerance
  )
    const
  {
    return this-&gt;disk::isApprox(rib_in) &amp;&amp;
           acme::isApprox(this-&gt;m_width, rib_in.m_width, tolerance) &amp;&amp;
           acme::isApprox(this-&gt;m_angle, rib_in.m_angle, tolerance);
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelop(
    triangleground::vecptr const &amp;localGround,
    std::vector&lt;size_t&gt;    const &amp;tris,
    affine                 const &amp;affine_in,
    std::string            const  method,
    output                       &amp;out
  )
    const
  {
    if (method == "geometric")
      return this-&gt;envelopGeometric(localGround, tris, affine_in, out);
    else if (method == "sampling")
      return this-&gt;envelopSampling(localGround, affine_in, out);
    else
      ENVE_ERROR("enve::rib::envelop(mesh, ...): invalid enveloping method.\n");
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelop(
    ground::flat const &amp;localGround,
    affine       const &amp;affine_in,
    std::string  const  method,
    output             &amp;out
  )
    const
  {
    if (method == "geometric")
      return this-&gt;envelopGeometric(localGround, affine_in, out);
    else if (method == "sampling")
      return this-&gt;envelopSampling(localGround, affine_in, out);
    else
      ENVE_ERROR("enve::rib::envelop(mesh, ...): invalid enveloping method.\n");
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelop(
    affine const &amp;affine_in,
    output       &amp;out
  )
    const
  {
    point origin(affine_in.translation());
    mat3  rotation(affine_in.linear());

    out.point    = origin + rotation * (this-&gt;center() - point(0.0, 0.0, this-&gt;radius()));
    out.normal   = rotation * UNITZ_VEC3;
    out.friction = 0.0;
    out.depth    = 0.0;
    out.area     = 0.0;
    out.volume   = 0.0;

    return false;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelopGeometric(
    triangleground::vecptr const &amp;localGround,
    std::vector&lt;size_t&gt;    const &amp;tris,
    affine                 const &amp;affine_in,
    output                       &amp;out
  )
    const
  {
    real  radius = this-&gt;radius();
    real  width  = this-&gt;width();
    point center = this-&gt;center();
    point origin(affine_in.translation());
    mat3  rotation(affine_in.linear());
    mat3  rotation_inv(rotation.transpose());

    bool int_bool = false;

    segment segment_tmp;
    vec3    normal_tmp;
    point   point_a, point_b;
    real    theta_a, theta_b;
    real    r_a, r_b, r_c, cos_theta_c, sin_theta_c;
    real    sectionArea;
    real    segmentLength_tmp;
    real    segmentArea_tmp;
    real    segmentVolume_tmp;
    real    segmentAreaTotal   = 0.0;
    real    segmentVolumeTotal = 0.0;

    point contactPoint_tmp    = point::Constant(0.0);
    vec3  contactNormal_tmp   = vec3::Constant(0.0);
    real  contactFriction_tmp = 0.0;

    point contactPoint_iter    = point::Constant(0.0);
    vec3  contactNormal_iter   = vec3::Constant(0.0);
    real  contactFriction_iter = 0.0;

    vec3  ribNormalGround(rotation * this-&gt;normal());
    point ribCenterGround(origin + rotation * center);
    disk  ribGround(radius, ribCenterGround, ribNormalGround);

    size_t i;
    for (size_t k = 0; k &lt; tris.size(); ++k)
    {
      i = tris[k];
      if (acme::intersection(*localGround[i], ribGround, segment_tmp, 1e-5))
      {
        // Find intersection points
        point_a = rotation_inv * (segment_tmp.vertex(0) - ribCenterGround);
        point_b = rotation_inv * (segment_tmp.vertex(1) - ribCenterGround);

        // Find angles
        theta_a = std::atan2(point_a.z(), point_a.x());
        theta_b = std::atan2(point_b.z(), point_b.x());

        // Check consistency
        segmentLength_tmp = segment_tmp.length();

        if(theta_b &lt; theta_a)
        {
          std::swap(theta_a, theta_b);
          std::swap(r_a, r_b);
        }

        // Check intersection
        if (theta_b - theta_a &lt; EPSILON_LOW &amp;&amp; segmentLength_tmp &lt; EPSILON_LOW)
        {
          break;
        }
        int_bool = true;

        // Find radius
        r_a = std::min(radius, std::max(0.0, point_a.norm()));
        r_b = std::min(radius, std::max(0.0, point_b.norm()));
        r_c = std::min(radius, std::max(0.0,
                (2*r_a*r_b) / std::max(EPSILON_LOW, (r_a+r_b)) * std::cos((theta_b-theta_a)/2.0)
              ));

        // Find area
        cos_theta_c = std::cos((theta_a + theta_b)/2);
        sin_theta_c = std::sin((theta_a + theta_b)/2);
        sectionArea = radius*radius*(theta_b-theta_a)/2 - r_a*r_b*std::sin(theta_b-theta_a)/2;

        // Store results
        segmentArea_tmp   = segmentLength_tmp * width;
        segmentAreaTotal += segmentArea_tmp;

        segmentVolume_tmp   = sectionArea * width;
        segmentVolumeTotal += segmentVolume_tmp;

        contactPoint_iter    = origin + rotation * (center + r_c * point(cos_theta_c, 0.0, sin_theta_c));
        normal_tmp           = rotation * vec3(-cos_theta_c, 0.0, -sin_theta_c);
        contactNormal_iter   = (normal_tmp + ribNormalGround * (localGround[i]-&gt;normal() - normal_tmp).dot(ribNormalGround)).normalized();
        contactFriction_iter = localGround[i]-&gt;friction();

        contactPoint_tmp    += segmentVolume_tmp * contactPoint_iter;
        contactNormal_tmp   += segmentVolume_tmp * contactNormal_iter;
        contactFriction_tmp += segmentVolume_tmp * contactFriction_iter;
      }
    }
    if (int_bool)
    {
      segmentAreaTotal   = std::max(segmentAreaTotal,   EPSILON_HIGH);
      segmentVolumeTotal = std::max(segmentVolumeTotal, EPSILON_HIGH);

      out.point    = contactPoint_tmp    / segmentVolumeTotal;
      out.normal   = (contactNormal_tmp  / segmentVolumeTotal).normalized();
      out.friction = contactFriction_tmp / segmentVolumeTotal;
      out.depth    = radius - (out.point - ribCenterGround).norm();
      out.area     = segmentAreaTotal;
      out.volume   = segmentVolumeTotal;
      return true;
    }
    else
    {
      out.point    = origin + rotation * (center - point(0.0, 0.0, radius));
      out.normal   = rotation * UNITZ_VEC3;
      out.friction = 0.0;
      out.depth    = 0.0;
      out.area     = 0.0;
      out.volume   = 0.0;
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelopGeometric(
    ground::flat const &amp;localGround,
    affine       const &amp;affine_in,
    output             &amp;out
  )
    const
  {
    real  radius = this-&gt;radius();
    real  width  = this-&gt;width();
    point center(this-&gt;center());
    point origin(affine_in.translation());
    mat3  rotation(affine_in.linear());

    vec3  ribNormalGround(rotation * this-&gt;normal());
    point ribCenterGround(origin + rotation * center);
    disk ribGround(radius, ribCenterGround, ribNormalGround);

    segment segment_tmp;
    vec3    normal_tmp;

    bool int_bool = acme::intersection(localGround, ribGround, segment_tmp, EPSILON_HIGH);
    if (int_bool &amp;&amp; segment_tmp.length() &gt; EPSILON_LOW)
    {
      out.point    = segment_tmp.centroid();
      normal_tmp   = (ribNormalGround.cross(ribCenterGround - out.point)).normalized();
      out.normal   = (localGround.normal() - normal_tmp * localGround.normal().dot(normal_tmp)).normalized();
      out.friction = localGround.friction();
      out.depth    = radius - (out.point - ribCenterGround).norm();
      out.area     = 2*std::sqrt(out.depth*(2*radius-out.depth))*width;
      out.volume   = (radius*radius*std::acos((radius-out.depth)/radius) -
                     (radius-out.depth)*std::sqrt(out.depth*(2*radius-out.depth)))*width;
      return true;
    }
    else
    {
      out.point    = origin + rotation * (center - point(0.0, 0.0, radius));
      out.normal   = rotation * UNITZ_VEC3;
      out.friction = 0.0;
      out.depth    = 0.0;
      out.area     = 0.0;
      out.volume   = 0.0;
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelopSampling(
    triangleground::vecptr const &amp;localGround,
    affine                 const &amp;affine_in,
    output                       &amp;out
  )
    const
  {
    real  radius = this-&gt;radius();
    real  width  = this-&gt;width();
    point center(this-&gt;center());
    point origin(affine_in.translation());
    mat3  rotation(affine_in.linear());

    vec3  deltaX(0.1*radius, 0.0, 0.0);
    vec3  deltaY(0.0, 0.3*width, 0.0);
    std::vector&lt;point&gt; point_vec(4);
    vec3               normal_tmp;
    std::vector&lt;real&gt;  friction_vec(4);
    vec3  ribNormalGround(rotation * this-&gt;normal());
    point ribCenterGround(origin + rotation * center);

    vec3  lineDirection(-UNITZ_VEC3);
    bool sampling = true;
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center + deltaX), lineDirection,
                                              point_vec[0], normal_tmp, friction_vec[0]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center - deltaX), lineDirection,
                                              point_vec[1], normal_tmp, friction_vec[1]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center + deltaY), lineDirection,
                                              point_vec[2], normal_tmp, friction_vec[2]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center - deltaY), lineDirection,
                                              point_vec[3], normal_tmp, friction_vec[3]);

    out.point  = (point_vec[0] + point_vec[1] + point_vec[2] + point_vec[3]) / 4.0;
    out.normal = ((point_vec[0] - point_vec[1]).cross(point_vec[2] - point_vec[3])).normalized();

    vec3 e_y = affine_in.linear().col(1);
    vec3 e_x = (out.normal.cross(e_y)).normalized();
    vec3 e_z = (e_y.cross(e_x)).normalized();

    out.depth = radius*std::abs(out.normal.dot(e_z)) - (out.point - ribCenterGround).norm();

    if ( sampling &amp;&amp; out.depth &gt; 0.0 )
    {
      out.friction = (friction_vec[0] + friction_vec[1] + friction_vec[2] + friction_vec[3]) / 4.0;
      out.area     = 2*std::sqrt(out.depth*(2*radius-out.depth))*width;
      out.volume   = (radius*radius*std::acos((radius-out.depth)/radius) -
                     (radius-out.depth)*std::sqrt(out.depth*(2*radius-out.depth)))*width;
      return true;
    }
    else
    {
      out.point    = origin + rotation * (center - point(0.0, 0.0, radius));
      out.normal   = rotation * UNITZ_VEC3;
      out.friction = 0.0;
      out.depth    = 0.0;
      out.area     = 0.0;
      out.volume   = 0.0;
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::envelopSampling(
    ground::flat const &amp;localGround,
    affine       const &amp;affine_in,
    output             &amp;out
  )
    const
  {
    real  radius = this-&gt;radius();
    real  width  = this-&gt;width();
    point center(this-&gt;center());
    point origin(affine_in.translation());
    mat3  rotation(affine_in.linear());

    vec3  deltaX(0.1*radius, 0.0, 0.0);
    vec3  deltaY(0.0, 0.3*width, 0.0);
    std::vector&lt;point&gt; point_vec(4);
    vec3               normal_tmp;
    std::vector&lt;real&gt;  friction_vec(4);
    vec3  ribNormalGround(rotation * this-&gt;normal());
    point ribCenterGround(origin + rotation * center);

    vec3  lineDirection(-UNITZ_VEC3);
    bool sampling = true;
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center + deltaX), lineDirection,
                                              point_vec[0], normal_tmp, friction_vec[0]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center - deltaX), lineDirection,
                                              point_vec[1], normal_tmp, friction_vec[1]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center + deltaY), lineDirection,
                                              point_vec[2], normal_tmp, friction_vec[2]);
    sampling = sampling &amp;&amp; this-&gt;samplingLine(localGround, origin + rotation * (center - deltaY), lineDirection,
                                              point_vec[3], normal_tmp, friction_vec[3]);

    out.point  = (point_vec[0] + point_vec[1] + point_vec[2] + point_vec[3]) / 4.0;
    out.normal = ((point_vec[0] - point_vec[1]).cross(point_vec[2] - point_vec[3])).normalized();

    vec3 e_y = affine_in.linear().col(1);
    vec3 e_x = (out.normal.cross(e_y)).normalized();
    vec3 e_z = (e_y.cross(e_x)).normalized();

    out.depth  = radius*std::abs(out.normal.dot(e_z)) - (out.point - ribCenterGround).norm();

    if ( sampling &amp;&amp; out.depth &gt; 0.0 )
    {
      out.friction = (friction_vec[0] + friction_vec[1] + friction_vec[2] + friction_vec[3]) / 4.0;
      out.area     = 2*std::sqrt(out.depth*(2*radius-out.depth))*width;
      out.volume   = (radius*radius*std::acos((radius-out.depth)/radius) -
                     (radius-out.depth)*std::sqrt(out.depth*(2*radius-out.depth)))*width;
      return true;
    }
    else
    {
      out.point    = origin + rotation * (center - point(0.0, 0.0, radius));
      out.normal   = rotation * UNITZ_VEC3;
      out.friction = 0.0;
      out.depth    = 0.0;
      out.area     = 0.0;
      out.volume   = 0.0;
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::samplingLine(
    triangleground::vecptr const &amp;localGround,
    point                  const &amp;origin,
    vec3                   const &amp;direction,
    point                        &amp;contactPoint,
    vec3                         &amp;contactNormal,
    real                         &amp;contactFriction
  )
    const
  {
    size_t             localGroundSize = localGround.size();
    point              point_tmp;
    std::vector&lt;point&gt; point_vec;
    std::vector&lt;vec3&gt;  normal_vec;
    std::vector&lt;real&gt;  friction_vec;
    point_vec.reserve(localGroundSize);
    normal_vec.reserve(localGroundSize);
    friction_vec.reserve(localGroundSize);
    bool               int_bool = false;
    for (size_t i = 0; i &lt; localGroundSize; ++i)
    {
      if (acme::intersection(line(origin, direction), *localGround[i], point_tmp, EPSILON_HIGH))
      {
        point_vec.push_back(point_tmp);
        normal_vec.push_back(localGround[i]-&gt;normal());
        friction_vec.push_back(localGround[i]-&gt;friction());
        int_bool = true;
      }
    }
    // Select the highest intersection point
    if (point_vec.size() == 1 &amp;&amp; int_bool)
    {
      contactPoint    = point_vec[0];
      contactNormal   = normal_vec[0];
      contactFriction = friction_vec[0];
      return true;
    }
    else if (point_vec.size() &gt; 1 &amp;&amp; int_bool)
    {
      contactPoint    = point_vec[0];
      contactNormal   = normal_vec[0];
      contactFriction = friction_vec[0];
      for (size_t j = 1; j &lt; point_vec.size(); ++j)
      {
        if (point_vec[j].z() &gt; contactPoint.z())
        {
          contactPoint    = point_vec[j];
          contactNormal   = normal_vec[j];
          contactFriction = friction_vec[j];
        }
      }
      return true;
    }
    else if (localGroundSize &gt; 0 &amp;&amp; !int_bool)
    {
      // Flying over the mesh
      return false;
    }
    else if (localGroundSize == 0)
    {
      // Out of mesh
      return false;
    }
    else
    {
      ENVE_ERROR("enve::rib::samplingLine(mesh, ...): condition not handled.\n");
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::samplingLine(
    ground::flat const &amp;localGround,
    point        const &amp;origin,
    vec3         const &amp;direction,
    point              &amp;contactPoint,
    vec3               &amp;contactNormal,
    real               &amp;contactFriction
  )
    const
  {
    if (acme::intersection(line(origin, direction), localGround, contactPoint, EPSILON_HIGH))
    {
      contactNormal   = localGround.normal();
      contactFriction = localGround.friction();
      return true;
    }
    else
    {
      return false;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  bool
  rib::intersection(
    line     const &amp;line_in,
    triangle const &amp;triangle_in,
    point          &amp;point_out,
    real            tolerance
  )
    const
  {
    point vertex0(triangle_in.vertex(0));
    point vertex1(triangle_in.vertex(1));
    point vertex2(triangle_in.vertex(2));
    vec3  edge1(vertex1 - vertex0);
    vec3  edge2(vertex2 - vertex0);
    point origin(line_in.origin());
    vec3  direction(line_in.direction());

    vec3 h, s, q;
    real a, f, u, v;
    h = direction.cross(edge2);
    a = edge1.dot(h);
    if (a &gt; -tolerance &amp;&amp; a &lt; tolerance)
      return false;
    real tolerance_space = 2.5e-02;
    f = 1.0 / a;
    s = origin - vertex0;
    u = f * s.dot(h);
    if (u &lt; 0.0-tolerance_space || u &gt; 1.0+tolerance_space)
      return false;
    q = s.cross(edge1);
    v = f * direction.dot(q);
    if (v &lt; 0.0-tolerance_space || u + v &gt; 1.0+tolerance_space)
      return false;
    real t    = f * edge2.dot(q);
    point_out = origin + t * direction;
    return true;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

} // namespace enve
</pre></div>
</div>
</div>



          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">The ENVE library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">How to use ENVE</a></li>
<li class="toctree-l1"><a class="reference internal" href="root.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-matlab/root.html">MATLAB API</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Davide Stocco.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>